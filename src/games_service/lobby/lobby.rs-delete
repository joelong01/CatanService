#![allow(dead_code)]

use scopeguard::defer;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

use crate::{
    games_service::game_container::game_messages::{
        CatanMessage, GameCreatedData, LobbyUser,
    },
    thread_info, trace_function, shared::models::{LongPollUser, GameError},
};

lazy_static::lazy_static! {
    // Initialize singleton lobby instance
    static ref LOBBY: Arc<RwLock<Lobby2>> = Arc::new(RwLock::new(Lobby2::new()));
}



pub struct Lobby2 {
    visitors: HashMap<String, LongPollUser>,
  
}

impl Lobby2 {
    /// Create a new Lobby
    pub fn new() -> Self {

        Self {
            visitors: HashMap::new(),
        }
    }

    /// Adds a new LobbyVisitor to the lobby if not already present.
    pub async fn join_lobby(user_id: &str, name: &str) {
        let mut lobby = LOBBY.write().await;
        let visitor = LongPollUser::new(user_id, name);
        lobby.visitors.insert(user_id.into(), visitor);
    }

    /// Removes a LobbyVisitor from the lobby, if present.
    pub async fn leave_lobby(user_id: &str) {
        trace_function!("leave_lobby", "user_id: {}", user_id);
        let mut lobby = LOBBY.write().await;
        lobby.visitors.remove(user_id);
    }

    /// Returns a list of user_ids in the current lobby.
    pub async fn copy_lobby() -> Vec<LobbyUser> {
        let lobby = LOBBY.read().await;
        let mut users = Vec::new();
        for v in lobby.visitors.values() {
            let user = LobbyUser {
                user_id: v.user_id.clone(),
                user_name: v.name.clone(),
            };
            users.push(user);
        }

        users
    }
    //
    //  send a message to the lobby waiter that a game has been created.  the client should get this and use
    //  the game_id to wait in the GameContainer
    pub async fn game_created(game_id: &str, user_id: &str) -> Result<(), String> {
        trace_function!("game_created", "user_id: {}", user_id);
        let msg = GameCreatedData {
            user_id: user_id.to_owned(),
            game_id: game_id.to_owned(),
        };
        match Lobby::send_message(user_id, &CatanMessage::GameCreated(msg)).await {
            Ok(_) => Ok(()),
            Err(e) => Err(format!("failed to send message in game_created {:?}", e)),
        }
    }
    /// Awaits for an message.
    pub async fn wait_in_lobby(user_id: &str) -> Result<CatanMessage, GameError> {
        trace_function!("wait_in_lobby", "user_id: {}", user_id);
        let rx = {
            let ro_lobby = LOBBY.read().await;
            if let Some(visitor) = ro_lobby.visitors.get(user_id) {
                visitor.rx.clone() // clone the Ar<RwLock>, not the rx
            } else {
                return Err(GameError::BadId(format!("{} not found", user_id)));
            }
        };
    
        let mut rx_lock = rx.write().await;
    
        // Now the read lock and Mutex lock are dropped, and you can await the message
        match rx_lock.recv().await {
            Some(msg) => Ok(msg),
            None => {
                thread_info!(
                    "wait_in_loby",
                    "ERROR: recv() for failed to return data. user_id: {}",
                    user_id,
                );
                return Err(GameError::ChannelError("Error in wait_in_lobby in recv".to_string()));
            }
        }
    }
    
    pub async fn send_message(to_id: &str, message: &CatanMessage) -> Result<(), String> {
        trace_function!("send_message", "to: {}, message: {:?}", to_id, message);
        let lobby = LOBBY.read().await;
        if let Some(visitor) = lobby.visitors.get(to_id) {
            visitor.tx.send(message.clone()).await.map_err(|e| e.to_string())
        } else {
            Err("User not found in the lobby".into())
        }
    }
}

            !lobby_after_leave
                .iter()
                .any(|user| user.user_id == user_id.to_string()),
            "Lobby should not contain user after leaving"
        );

        // Attempt to leave the lobby again (double leave)
        Lobby::leave_lobby(&user_id).await;
        let lobby_after_double_leave = Lobby::copy_lobby().await;
        assert!(
            !lobby_after_double_leave
                .iter()
                .any(|user| user.user_id == user_id.to_string()),
            "Lobby should still not contain user after double leaving"
        );
    }
}
